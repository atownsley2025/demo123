<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Endless Outdoor Runner</title>
<style>
  body {
    margin:0; 
    background:#87ceeb;
    color:#fff; font-family:sans-serif; display:flex; flex-direction:column; align-items:center;
  }
  canvas {
    border:2px solid #1e2f78; border-radius:12px;
    box-shadow:0 10px 30px #0006; margin-top:8px;
  }
  #hud {margin:10px;font-size:18px;color:#111;font-weight:bold}
  button {
    margin:6px; padding:10px 14px; border-radius:8px; border:none;
    background:#1e2f78; color:#fff; font-weight:600; cursor:pointer
  }
</style>
</head>
<body>
<h2 style="color:#111;">Endless Outdoor Runner</h2>
<div id="hud">Level: <span id="lvl">1</span> · Attempts: <span id="tries">0</span> · Jumps: <span id="jumps">0</span></div>
<canvas id="game" width="800" height="400"></canvas>
<div>
  <button id="btnStart">▶ Start</button>
  <button id="btnStop">⏸ Stop</button>
</div>

<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
const hudLvl=document.getElementById("lvl");
const hudTries=document.getElementById("tries");
const hudJumps=document.getElementById("jumps");
const btnStart=document.getElementById("btnStart");
const btnStop=document.getElementById("btnStop");

const GROUND_Y=340;
let STATE="idle";
let attemptCount=0, jumpCount=0, level=1;

const player={x:80,y:GROUND_Y-28,r:16,vy:0,onGround:true,jumpsLeft:2,maxJumps:2};
const input={justPressed:false};
const gravity=0.6;
let baseSpeed=3.5;  // easier start
let speed=baseSpeed;
let baseSpawn=220;  // base spawn delay
let obstacles=[]; 
let spawnTimer=0;
let animationId;

// Clouds
let clouds=[];
for(let i=0;i<5;i++){
  clouds.push({x:i*160+Math.random()*100,y:40+Math.random()*60,w:60+Math.random()*40,h:30+Math.random()*15});
}

// Obstacle flower colors
const flowerColors=["#FF6B6B","#FFD93D","#6BCB77","#4D96FF","#FF6EC7"];
let colorIndex=0;

const COLORS={
  player:"#FFD43B",
  ground:"#2E8B57" // green grass
};

function pressJump(){input.justPressed=true;}
window.addEventListener("keydown",e=>{
  if(["Space","ArrowUp","KeyW"].includes(e.code)){e.preventDefault();pressJump();}
});
canvas.addEventListener("pointerdown",pressJump);

btnStart.onclick=()=>{ if(STATE!=="running"){resetGame();STATE="running"; loop();} };
btnStop.onclick=()=>{ STATE="paused"; cancelAnimationFrame(animationId); };

function resetGame(){
  attemptCount=0; jumpCount=0; level=1;
  hudTries.textContent=attemptCount;
  hudJumps.textContent=jumpCount;
  hudLvl.textContent=level;
  obstacles=[]; spawnTimer=0;
  resetPlayer(); speed=baseSpeed;
  colorIndex=0;
}

function resetPlayer(){
  Object.assign(player,{x:80,y:GROUND_Y-player.r*2,vy:0,onGround:true,jumpsLeft:2});
}

function circleRectCollide(circle,rect){
  const cx=circle.x+circle.r, cy=circle.y+circle.r;
  const rx=Math.max(rect.x,Math.min(cx,rect.x+rect.w));
  const ry=Math.max(rect.y,Math.min(cy,rect.y+rect.h));
  const dx=cx-rx, dy=cy-ry;
  return dx*dx+dy*dy < circle.r*circle.r;
}

function update(){
  if(STATE!=="running")return;

  // spawn obstacles
  spawnTimer-=speed;
  if(spawnTimer<=0){
    const type=Math.random()<0.5?"bush":"flower";
    obstacles.push({x:canvas.width+40,type:type,size:30+Math.random()*15,y:GROUND_Y});
    spawnTimer=baseSpawn - (level*5) + Math.random()*120; // harder: less delay
    if(spawnTimer<80) spawnTimer=80; // cap so not impossible
  }
  // move
  for(const o of obstacles){o.x-=speed;}
  obstacles=obstacles.filter(o=>o.x+o.size>0);

  // move clouds
  for(const c of clouds){c.x-=0.5; if(c.x+c.w<0) c.x=canvas.width+Math.random()*100;}

  // physics
  player.vy+=gravity;
  if(input.justPressed && player.jumpsLeft>0){
    player.vy=-12;
    player.onGround=false;
    player.jumpsLeft--;
    jumpCount++; hudJumps.textContent=jumpCount;
    if(jumpCount%10===0 && jumpCount>0){
      level++; hudLvl.textContent=level;
      speed=baseSpeed+level*0.3; // faster with levels
      colorIndex=(colorIndex+1)%flowerColors.length;
    }
  }
  input.justPressed=false;

  player.y+=player.vy;
  if(player.y+player.r*2>=GROUND_Y){
    player.y=GROUND_Y-player.r*2;
    player.vy=0;
    if(!player.onGround){
      player.onGround=true; player.jumpsLeft=player.maxJumps;
    }
  } else {player.onGround=false;}

  // collisions
  for(const o of obstacles){
    let rect={x:o.x,y:o.y-o.size,w:o.size,h:o.size};
    if(circleRectCollide(player,rect)){
      attemptCount++; hudTries.textContent=attemptCount;
      // reset progress
      jumpCount=0; level=1;
      hudJumps.textContent=jumpCount; hudLvl.textContent=level;
      resetPlayer(); obstacles=[]; spawnTimer=0;
      speed=baseSpeed;
      break;
    }
  }
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // gradient sky
  let sky=ctx.createLinearGradient(0,0,0,GROUND_Y);
  sky.addColorStop(0,"#87CEFA");
  sky.addColorStop(1,"#cceeff");
  ctx.fillStyle=sky;
  ctx.fillRect(0,0,canvas.width,GROUND_Y);

  // sun
  ctx.fillStyle="#FFD43B";
  ctx.beginPath();
  ctx.arc(canvas.width-80,80,40,0,Math.PI*2);
  ctx.fill();

  // clouds
  ctx.fillStyle="rgba(255,255,255,0.85)";
  for(const c of clouds){
    ctx.beginPath();
    ctx.ellipse(c.x,c.y,c.w/2,c.h/2,0,0,Math.PI*2);
    ctx.ellipse(c.x+20,c.y-10,c.w/2.5,c.h/2.5,0,0,Math.PI*2);
    ctx.ellipse(c.x+40,c.y,c.w/2.5,c.h/2.5,0,0,Math.PI*2);
    ctx.fill();
  }

  // static trees
  drawTree(200,GROUND_Y-100,1);
  drawTree(400,GROUND_Y-110,1.2);
  drawTree(600,GROUND_Y-90,0.9);

  // ground
  ctx.fillStyle=COLORS.ground;
  ctx.fillRect(0,GROUND_Y,canvas.width,canvas.height-GROUND_Y);

  // obstacles
  for(const o of obstacles){
    if(o.type==="bush"){
      ctx.fillStyle="#228B22";
      ctx.beginPath();
      ctx.arc(o.x+o.size/2,o.y-10,o.size/2,0,Math.PI*2);
      ctx.fill();
    } else if(o.type==="flower"){
      ctx.strokeStyle="#2E8B57"; ctx.lineWidth=3;
      ctx.beginPath();
      ctx.moveTo(o.x+o.size/2,o.y);
      ctx.lineTo(o.x+o.size/2,o.y-o.size);
      ctx.stroke();
      ctx.fillStyle=flowerColors[colorIndex];
      ctx.beginPath();
      ctx.arc(o.x+o.size/2,o.y-o.size,8,0,Math.PI*2);
      ctx.fill();
    }
  }

  // player
  ctx.fillStyle=COLORS.player;
  ctx.beginPath();
  ctx.arc(player.x+player.r,player.y+player.r,player.r,0,Math.PI*2);
  ctx.fill();
}

function drawTree(x,y,scale){
  ctx.fillStyle="#4d2e0b";
  ctx.fillRect(x-5*scale,y,10*scale,50*scale);
  ctx.fillStyle="#006400";
  ctx.beginPath();
  ctx.moveTo(x,y-50*scale);
  ctx.lineTo(x-40*scale,y+10*scale);
  ctx.lineTo(x+40*scale,y+10*scale);
  ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x,y-80*scale);
  ctx.lineTo(x-30*scale,y-20*scale);
  ctx.lineTo(x+30*scale,y-20*scale);
  ctx.closePath();
  ctx.fill();
}

function loop(){
  update(); draw();
  animationId=requestAnimationFrame(loop);
}
</script>
</body>
</html>

