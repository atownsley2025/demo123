<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Impossible â€” 5 Levels (HTML)</title>
<style>
  :root{
    --bg:#081229;
    --ground:#0f9bd8;
    --player:#ff9f1c;
    --ob:#ff3b30;
    --accent:#9be7ff;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;}
  body{background:linear-gradient(180deg,var(--bg) 0%, #001428 100%); color:#dbefff; display:flex;align-items:center;justify-content:center;}
  #container{width:960px;max-width:96vw;padding:12px;}
  canvas{display:block;width:100%;height:480px;background:linear-gradient(180deg,#021427 0%, #06283b 100%);border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.6);}
  .hud{display:flex;justify-content:space-between;align-items:center;margin-top:8px;gap:8px;flex-wrap:wrap;}
  .panel{background:rgba(255,255,255,.04);padding:8px 12px;border-radius:8px;font-size:14px;}
  button{background:var(--accent);color:#012;border:0;padding:8px 10px;border-radius:8px;font-weight:600;cursor:pointer;}
  button:active{transform:translateY(1px);}
  .muted{opacity:.6}
  .big{font-size:18px;font-weight:700}
  .center{display:flex;gap:8px;align-items:center}
  @media (max-width:520px){ canvas{height:360px;} }
</style>
</head>
<body>
<div id="container">
  <canvas id="c" width="960" height="480"></canvas>
  <div class="hud">
    <div class="panel center">
      <div class="big" id="levelLabel">Level 1</div>
      <div style="width:12px"></div>
      <div id="status">Running</div>
    </div>
    <div class="panel center">
      <div>Distance: <span id="dist">0</span> / <span id="goal">1200</span></div>
    </div>
    <div class="panel center">
      <div>Attempts: <span id="attempts">0</span></div>
      <div style="width:8px"></div>
      <div>Deaths: <span id="deaths">0</span></div>
    </div>
    <div class="panel center">
      <button id="restartBtn">Restart Level</button>
      <button id="muteBtn">ðŸ”Š</button>
    </div>
  </div>
</div>

<script>
/*
  Impossible-style HTML/JS game with 5 levels.
  Controls: Space / ArrowUp / Click / Tap
  - Auto-run to the right.
  - Jump with single/double jump if allowed (double jump enabled in later levels).
  - Collide with obstacles -> restart level.
  - Reach levelGoal -> next level or win.
*/

// ---- Config / Level Data ----
const levels = [
  // each level has: goal (distance), speed, gravity, jumpPower, obstacles array [{x,w,h,yOffset}]
  {
    name: "Level 1 â€” Warmup",
    goal: 1200,
    speed: 2.2,
    gravity: 0.9,
    jump: 12.2,
    doubleJump: false,
    obstacles: [
      {x: 300, w: 36, h: 70},
      {x: 520, w: 44, h: 84},
      {x: 760, w: 28, h: 72},
      {x: 940, w: 40, h: 92},
      {x: 1200, w: 36, h: 70},
      {x: 1500, w: 64, h: 110}
    ]
  },
  {
    name: "Level 2 â€” Faster",
    goal: 1400,
    speed: 2.8,
    gravity: 1.0,
    jump: 12.6,
    doubleJump: true,
    obstacles: [
      {x: 260, w: 48, h: 80},
      {x: 420, w: 36, h: 86},
      {x: 610, w: 60, h: 120},
      {x: 820, w: 30, h: 80},
      {x: 1040, w: 44, h: 96},
      {x: 1340, w: 60, h: 120},
      {x: 1520, w: 36, h: 86}
    ]
  },
  {
    name: "Level 3 â€” Tight Timings",
    goal: 1600,
    speed: 3.4,
    gravity: 1.06,
    jump: 13.2,
    doubleJump: true,
    obstacles: [
      {x: 220, w: 28, h: 78},
      {x: 320, w: 28, h: 78},
      {x: 420, w: 44, h: 100},
      {x: 520, w: 28, h: 78},
      {x: 640, w: 80, h: 140},
      {x: 880, w: 28, h: 78},
      {x: 960, w: 28, h: 78},
      {x: 1080, w: 60, h: 120},
      {x: 1280, w: 36, h: 86}
    ]
  },
  {
    name: "Level 4 â€” Spike Chains",
    goal: 1800,
    speed: 3.9,
    gravity: 1.12,
    jump: 13.6,
    doubleJump: true,
    obstacles: [
      {x: 200, w: 28, h: 84},
      {x: 260, w: 28, h: 84},
      {x: 320, w: 28, h: 84},
      {x: 420, w: 60, h: 140},
      {x: 620, w: 36, h: 100},
      {x: 700, w: 28, h: 84},
      {x: 820, w: 44, h: 110},
      {x: 980, w: 28, h: 84},
      {x: 1160, w: 64, h: 140},
      {x: 1360, w: 44, h: 110}
    ]
  },
  {
    name: "Level 5 â€” The Impossible",
    goal: 2000,
    speed: 4.6,
    gravity: 1.16,
    jump: 14.0,
    doubleJump: true,
    obstacles: [
      {x: 160, w: 28, h: 84},
      {x: 220, w: 28, h: 84},
      {x: 300, w: 44, h: 110},
      {x: 420, w: 28, h: 84},
      {x: 520, w: 28, h: 84},
      {x: 640, w: 60, h: 140},
      {x: 800, w: 28, h: 84},
      {x: 880, w: 28, h: 84},
      {x: 980, w: 44, h: 120},
      {x: 1160, w: 64, h: 150},
      {x: 1380, w: 36, h: 96},
      {x: 1560, w: 80, h: 170}
    ]
  }
];

// ---- Globals ----
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;
const groundY = H - 64;
let levelIndex = 0;
let attemptCount = 0, deathCount = 0;
let muted = false;

// HUD elements
const levelLabel = document.getElementById('levelLabel');
const statusTxt = document.getElementById('status');
const distTxt = document.getElementById('dist');
const goalTxt = document.getElementById('goal');
const attemptsTxt = document.getElementById('attempts');
const deathsTxt = document.getElementById('deaths');
const restartBtn = document.getElementById('restartBtn');
const muteBtn = document.getElementById('muteBtn');

let gameState; // holds dynamic state for current level

// ---- Audio ----
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function ensureAudio(){
  if(muted) return;
  if(!audioCtx) audioCtx = new AudioCtx();
}
function playClick(freq=880, time=0.03, when=0){
  if(muted) return;
  ensureAudio();
  if(!audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'square';
  o.frequency.value = freq;
  g.gain.value = 0.08;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(audioCtx.currentTime + when);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + when + time);
  o.stop(audioCtx.currentTime + when + time + 0.02);
}

// ---- Player ----
function makeStateFromLevel(lv){
  return {
    lvl: lv,
    px: 120,          // player x (screen space fixed)
    py: groundY - 36, // player y (top)
    vy: 0,
    w: 36,
    h: 36,
    onGround: true,
    canDoubleJump: lv.doubleJump,
    usedDouble: false,
    scroll: 0,      // world scroll offset (how far progressed)
    speed: lv.speed,
    alive: true,
    goal: lv.goal,
    flash: 0,
    startTime: performance.now()
  };
}

// ---- Input ----
let keys = {};
function jump(){
  if(!gameState.alive) return;
  // single jump
  if(gameState.onGround){
    gameState.vy = -gameState.lvl.jump;
    gameState.onGround = false;
    gameState.usedDouble = false;
    playClick(880, 0.06);
  } else if(gameState.canDoubleJump && !gameState.usedDouble){
    gameState.vy = -gameState.lvl.jump * 0.88;
    gameState.usedDouble = true;
    playClick(1100, 0.06);
  }
}
window.addEventListener('keydown', e=>{
  if(e.code === 'Space' || e.code === 'ArrowUp'){
    e.preventDefault();
    keys[e.code] = true;
    jump();
    if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
  }
});
window.addEventListener('keyup', e=>{
  keys[e.code] = false;
});
canvas.addEventListener('mousedown', e=>{
  jump();
  if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
});
canvas.addEventListener('touchstart', e=>{
  e.preventDefault();
  jump();
  if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
}, {passive:false});

// ---- Collision ----
function intersects(ax,ay,aw,ah, bx,by,bw,bh){
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

// ---- Game loop ----
function startLevel(index){
  levelIndex = index;
  const lv = levels[levelIndex];
  gameState = makeStateFromLevel(lv);
  levelLabel.textContent = lv.name;
  goalTxt.textContent = lv.goal;
  statusTxt.textContent = "Running";
  attemptsTxt.textContent = attemptCount;
  deathsTxt.textContent = deathCount;
  playClick(660, 0.05);
}

function restartLevel(){
  attemptCount++;
  attemptsTxt.textContent = attemptCount;
  startLevel(levelIndex);
}

restartBtn.addEventListener('click', ()=> restartLevel());
muteBtn.addEventListener('click', ()=>{
  muted = !muted;
  muteBtn.textContent = muted ? 'ðŸ”‡' : 'ðŸ”Š';
});

function tick(t){
  if(!gameState) return;
  // physics & scroll only when alive
  if(gameState.alive){
    // horizontal progress
    gameState.scroll += gameState.speed * 6; // multiplier for world-pixel scale
    // small speed ramp for dramatic effect
    if(gameState.scroll % 240 < 1) playClick(440 + Math.random()*160, 0.02);

    // vertical physics
    gameState.vy += gameState.lvl.gravity;
    gameState.py += gameState.vy;
    // ground collision
    if(gameState.py + gameState.h > groundY){
      gameState.py = groundY - gameState.h;
      gameState.vy = 0;
      gameState.onGround = true;
    } else {
      gameState.onGround = false;
    }

    // check collisions with obstacles
    const obs = gameState.lvl.obstacles;
    for(let i=0;i<obs.length;i++){
      const o = obs[i];
      const ox = o.x - gameState.scroll + gameState.px;
      const oy = groundY - o.h;
      // cull off-screen
      if(ox + o.w < -60 || ox > W + 60) continue;
      // use bounding box collision (approx for spike)
      if(intersects(gameState.px, gameState.py, gameState.w, gameState.h, ox, oy, o.w, o.h)){
        // died
        gameState.alive = false;
        gameState.flash = 18;
        deathCount++;
        deathsTxt.textContent = deathCount;
        statusTxt.textContent = "You Died";
        playClick(200, 0.3);
        break;
      }
    }

    // level complete?
    if(gameState.scroll >= gameState.goal){
      // reached goal
      gameState.alive = false;
      statusTxt.textContent = "Level Cleared!";
      playClick(1400, 0.12);
      setTimeout(()=> {
        levelIndex++;
        if(levelIndex >= levels.length){
          statusTxt.textContent = "All Levels Completed â€” YOU WIN!";
          playClick(2000, 0.4, 0.02);
          // freeze on win
        } else {
          // new level
          startLevel(levelIndex);
        }
      }, 700);
    }
  } else {
    // if dead, small camera shake/flash countdown
    if(gameState.flash > 0) gameState.flash--;
    else {
      // automatically restart after short pause
      setTimeout(()=> {
        restartLevel();
      }, 300);
      // set alive to null to prevent multiple restarts
      gameState.alive = null;
    }
  }
  render();
  requestAnimationFrame(tick);
}

// ---- Rendering ----
function render(){
  ctx.clearRect(0,0,W,H);

  // background gradient and parallax stars
  ctx.fillStyle = "#021826";
  ctx.fillRect(0,0,W,H);

  // subtle stars
  for(let s=0;s<60;s++){
    const sx = (s * 37 + (gameState ? gameState.scroll * 0.02 : 0)) % W;
    const sy = 40 + (s * 19) % (H - 180);
    ctx.fillStyle = "rgba(180,220,255,0.03)";
    ctx.fillRect(sx, sy, 2,2);
  }

  // ground
  ctx.fillStyle = "rgba(255,255,255,0.03)";
  ctx.fillRect(0,groundY, W, H-groundY);

  // draw obstacles
  const obs = levels[levelIndex].obstacles;
  for(let i=0;i<obs.length;i++){
    const o = obs[i];
    const ox = Math.round(o.x - gameState.scroll + gameState.px);
    const oy = groundY - o.h;
    // draw spike as triangle
    if(ox < -120 || ox > W + 120) continue;
    // spike body
    ctx.beginPath();
    ctx.moveTo(ox, oy + o.h);
    ctx.lineTo(ox + o.w/2, oy);
    ctx.lineTo(ox + o.w, oy + o.h);
    ctx.closePath();
    ctx.fillStyle = "rgba(255,59,48,0.98)";
    ctx.fill();
    // highlight
    ctx.beginPath();
    ctx.moveTo(ox + o.w*0.54, oy + o.h*0.02);
    ctx.lineTo(ox + o.w*0.6, oy + o.h*0.35);
    ctx.lineTo(ox + o.w*0.64, oy + o.h*0.02);
    ctx.closePath();
    ctx.fillStyle = "rgba(255,160,135,0.9)";
    ctx.fill();
  }

  // draw player (with small bob/flash)
  const bob = Math.sin(gameState.scroll * 0.02) * 1.5;
  ctx.save();
  if(gameState.flash > 0){
    const f = gameState.flash/18;
    ctx.globalAlpha = 0.4 + 0.6*f;
    // red tint flash
    ctx.fillStyle = `rgba(255,40,40,${0.2 + 0.6*f})`;
    ctx.fillRect(0,0,W,H);
  }
  // shadow
  ctx.fillStyle = "rgba(0,0,0,0.25)";
  ctx.fillRect(gameState.px+4, groundY - 6, gameState.w, 6);

  // player (rounded square)
  ctx.fillStyle = gameState.alive ? "#ff9f1c" : "#a34d21";
  roundRect(ctx, gameState.px, Math.round(gameState.py + bob), gameState.w, gameState.h, 6, true, false);

  // small eyes for personality
  ctx.fillStyle = "#111";
  ctx.fillRect(gameState.px + 8, Math.round(gameState.py + 10 + bob), 6,6);
  ctx.fillRect(gameState.px + 22, Math.round(gameState.py + 10 + bob), 6,6);
  ctx.restore();

  // progress bar
  const barW = 380;
  const barX = W - barW - 20;
  const barY = 16;
  ctx.fillStyle = "rgba(255,255,255,0.06)";
  roundRect(ctx, barX, barY, barW, 12, 6, true, false);
  const pct = Math.min(1, gameState.scroll / gameState.goal);
  ctx.fillStyle = "#9be7ff";
  roundRect(ctx, barX, barY, Math.max(4, Math.floor(barW * pct)), 12, 6, true, false);
  // goal marker
  ctx.fillStyle = "#ffd700";
  ctx.fillRect(barX + Math.floor(barW * (gameState.goal / Math.max(gameState.goal, gameState.goal))), barY - 2, 2, 16);

  // text overlays
  ctx.fillStyle = "#dbefff";
  ctx.font = "16px system-ui, Arial";
  ctx.fillText(levels[levelIndex].name, 18, 30);
  ctx.fillText(`Speed: ${levels[levelIndex].speed.toFixed(2)}  Gravity: ${levels[levelIndex].gravity.toFixed(2)}`, 18, 52);

  // distance numeric
  distTxt.textContent = Math.floor(gameState.scroll);

}

// helper: rounded rect
function roundRect(ctx, x, y, w, h, r, fill, stroke){
  if (typeof r === 'undefined') r = 5;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}

// init/resizing
function resize(){
  // keep fixed internal size (for consistent gameplay) but adapt CSS size - canvas width/height are fixed above
  W = canvas.width; H = canvas.height;
}
window.addEventListener('resize', resize);

// start
attemptCount = 0;
deathCount = 0;
startLevel(0);
requestAnimationFrame(tick);

// small guidance overlay on first run (console + quick click)
console.log("Controls: Space or Up to jump. Click/tap to jump. Good luck!");

// unlock audio on first interaction (user gesture)
document.addEventListener('keydown', ()=> { if(!audioCtx && !muted) ensureAudio(); }, {once:true});
document.addEventListener('mousedown', ()=> { if(!audioCtx && !muted) ensureAudio(); }, {once:true});
document.addEventListener('touchstart', ()=> { if(!audioCtx && !muted) ensureAudio(); }, {once:true});
</script>
</body>
</html>
